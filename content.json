{"meta":{"title":"虾米吃大鱼","subtitle":null,"description":null,"author":"ypc1202","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"推导式","slug":"推导式","date":"2018-06-20T07:05:14.000Z","updated":"2018-06-20T07:05:31.965Z","comments":true,"path":"2018/06/20/推导式/","link":"","permalink":"http://yoursite.com/2018/06/20/推导式/","excerpt":"","text":"类表推导式 打印0~9的平方。 1print([x * x for x in range(10)]) # =&gt; [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 打印0~6的平方。 1print([x * x for x in range(10) if x &lt; 7]) # =&gt; [0, 1, 4, 9, 16, 25, 36] 将列表里小于等于20000数据全部加1000。 1234salary_list = [13000,12700,15000,14000,25000,16000,18000,22000,32000]res = [ var + 1000 for var in salary_list if var &lt;= 20000 ]salary_list[:len(res)] = resprint(res) 字典推导式 将字典key和value交换 123DictIn=&#123;\"a\":1, \"b\":2, \"c\":3, \"d\":4&#125;DictOut=&#123;v:k for k,v in DictIn.items()&#125;print(DictOut) # =&gt; &#123;1: 'a', 2: 'b', 3: 'c', 4: 'd'&#125; 集合推导式 集合推导式跟列表推导式差不多，都是对一个列表的元素全部执行相同的操作， 但集合是一种无重复无序的序列 区别：跟列表推到式的区别在于：1.不使用中括号，使用大括号；2.结果中无重复；3.结果是一个set()集合，集合里面是一个序列 12squared = &#123; i * 2 for i in [1, 1, 2]&#125;print(squared) # =&gt; &#123;2, 4&#125;","categories":[],"tags":[]},{"title":"切片操作","slug":"切片操作","date":"2018-06-20T06:25:53.000Z","updated":"2018-06-20T06:25:53.472Z","comments":true,"path":"2018/06/20/切片操作/","link":"","permalink":"http://yoursite.com/2018/06/20/切片操作/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"面向对象属性探究","slug":"面向对象属性探究","date":"2018-06-14T09:10:58.000Z","updated":"2018-06-15T07:00:13.526Z","comments":true,"path":"2018/06/14/面向对象属性探究/","link":"","permalink":"http://yoursite.com/2018/06/14/面向对象属性探究/","excerpt":"","text":"1234567891011121314class Human: number = 0 def __init__(self,name): Human.number += 1 self.name = namehuman1 = Human(\"小红\") human2 = Human(\"小芳\")print(human1.number) # 类变量可以被实例和类同时访问 # =&gt; 2human2.number = 10print(Human.number) # =&gt; 2human3 = Human(\"小白\")print(human2.number) # =&gt; 10print(Human.number) # =&gt; 3 变量 实例的变量：只能被实例所访问(私有) 实例的变量可以被实例所使用 human1.name 实例.的方式来获取到属于实例的私有变量 属于实例的self.xxx 这样子的变量是无法通过类来直接访问的。因为这些属性需要实例化 self.xxx这样子的变量 是我的实例所私有的 类的变量：可以被实例，类同时访问(共享) 但是如果实例修改或者重新赋值了类的变量，那么这个变量将升级为私有的 如果这个变量没有提前出现过，我也赋值定义修改了，那么也会变成这个实例独有的。 内部的是独立私有的，外部的是大家公用的(共享) 类和实例均支持在创建之后，存活期间动态的添加新的属性 实例添加的时候，如果你只为一个单独实例添加，那么其他实例是不会有的 类添加的时候，大家都有 方法(函数) 实例的方法：只能被实例所调用，而且默认实例方法第一个位置上的参数，必须传递调用实 例！ def func(self)… xx.func 来调用一个实例函数，那么实例一定会作为第一个参数传递进来 函数中的self也可以让我们方便的直接获取到属于实例的私有变量 实例函数中可以访问其他实例属性：因为self来指向当前实例中的其他属性,self.other 123456789101112131415161718192021222324252627282930313233343536373839import randomclass Car: carNumber = 0 carList = [] colorList = [\"BALCK\",\"BLUE\",\"RED\"] def __init__(self,name): self.name = name #车的名字 self.gas = 0 #车的油量 self.colour = random.choice(Car.colorList) #车的颜色 choices是带括号的 # print(self.colour) Car.carNumber += 1 Car.carList.append(self) def changeColour(self,colour): print(\"%s改变颜色为:%s\" % (self.name,colour)) self.colour = colour def run(self): # 车子会跑 if self.gas &lt;= 0: print('%s车没油',self.name) else: print('%s跑了10Mile,消耗的1升汽油' % self.name) self.gas = self.gas - 10 #跑一次少10升 print(\"%s当前流量:%d\" % (self.name,self.gas)) def addGas(self,oil_num): #加油 self.gas += oil_num #加到油 print('%s加完油了,现在油量位:%d'%(self.name,self.gas)) car1 = Car('Ford')car2 = Car('Jaguar')car3 = Car('Mazda')# print(dir(random))# print(help(random.choices))# print(help(random.choice))for item in Car.carList: print(\"汽车的品牌为:%s,汽车的颜色为%s\" %(item.name,item.colour)) 类的方法 类的普通函数 权限完全封闭 啥都别想看 只能被类所使用，实例访问不了这种函数 不能访问类变量以及实例变量 123456789101112class A: place = '地球' def __init__(self): self.name = '哈哈哈' def func(): #函数没有任何参数 #类的普通函数 print(\"啊哈哈哈哈哈哈\")a = A()# a.func() #普通类方法 无法被实例调用A.func() #普通类方法，只能被类调用 类的高级函数 权限展开了类的变量访问权限 实例和类均可调用 可以访问属于类的变量 不可以访问属于实例的属性 你有了cls之后，也就可以互相指向到其他类中高级函数，也就可以调用了 可以在另外一个类中高级函数调用其他类的高级函数 1234567891011121314class A: place = '地球' @classmethod def g_func(cls): #默认的必须要有一个参数， #cls参数用来指向当前的类! print(cls.place) @classmethod def g_func1(cls): #默认的必须要有一个参数， cls.g_func()a = A()a.g_func() # =&gt; 地球a.g_func1() # =&gt; 地球 在这里，必须为类的高级函数第一个参数约定俗称的写一个cls形参 该形参用来接收使用的类 类的静态方法：开放了实例访问函数的权限，但是变量的权限访问(访问类、实例变量)全部关闭 首先无法访问属于类的变量，没有指向当前使用类的指针 实例和类均可调用 不可以访问属于实例的属性 1234567891011class A: @staticmethod #类似与类的普通函数 #不需要cls这样的额外参数 def s_func(): print('哈哈哈哈哈') #和我类数据无关的操作a = A()a.s_func() # =&gt; 哈哈哈哈哈A.s_func() # =&gt; 哈哈哈哈哈 实例之间可以通过静态方法@staticmethod以及高级类方法@classmethod可以进行数据通信 C++里面静态方法：共享，通信 cls用来指向类self用来指向实例","categories":[],"tags":[]},{"title":"CSV","slug":"CSV","date":"2018-06-13T06:01:14.000Z","updated":"2018-06-13T09:58:42.515Z","comments":true,"path":"2018/06/13/CSV/","link":"","permalink":"http://yoursite.com/2018/06/13/CSV/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"编码","slug":"编码","date":"2018-06-13T03:44:58.000Z","updated":"2018-06-13T03:49:21.811Z","comments":true,"path":"2018/06/13/编码/","link":"","permalink":"http://yoursite.com/2018/06/13/编码/","excerpt":"","text":"编码 默认情况下python3的源码文件以UTF-8编码,所有字符串都是unicode字符串. 此处参考https://wenku.baidu.com/view/cb9fe505cc17552707220865.html ​ 很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为”字节“。再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机“。 ​ 开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作： 遇上0×10, 终端就换行； 遇上0×07, 终端就向人们嘟嘟叫； 遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。 他们看到这样很好，于是就把这些0×20以下的字节状态称为”控制码”。他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 ​ 后来，就像建造巴比伦塔一样，世界各地都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用 127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128 到255这一页的字符集被称”扩展字符集“。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！ ​ 等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312“。GB2312 是对 ASCII 的中文扩展。 ​ 但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把GB2312 没有用到的码位找出来老实不客气地用上。后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK包括了GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS“（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍： “一个汉字算两个英文字符！一个汉字算两个英文字符……” ​ 因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，像是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 真是计算机的巴比伦塔命题啊！ ​ 正在这时，大天使加百列及时出现了——一个叫 ISO（国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号 的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “unicode“。 ​ unicode开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ASCII里的那些“半角”字符，unicode包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。 ​ 这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的 strlen 函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从unicode开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符“！同时，也都是统一的”两个字节“，请注意”字符”和”字节”两个术语的不同，“字节”是一个8位的物理存贮单元，而“字符”则是一个文化相关的符号。在unicode中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。 ​ unicode同样也不完美，这里就有两个的问题，一个是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的。 ​ unicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。UTF-8就是在互联网上使用最广的一种unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节）。从unicode到utf-8并不是直接的对应，而是要过一些算法和规则来转换。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制）—————————————————————–0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 最后简单总结一下： 中国人民通过对 ASCII 编码的中文扩充改造，产生了 GB2312 编码，可以表示6000多个常用汉字。 汉字实在是太多了，包括繁体和各种字符，于是产生了 GBK 编码，它包括了 GB2312 中的编码，同时扩充了很多。 中国是个多民族国家，各个民族几乎都有自己独立的语言系统，为了表示那些字符，继续把 GBK 编码扩充为 GB18030 编码。 每个国家都像中国一样，把自己的语言编码，于是出现了各种各样的编码，如果你不安装相应的编码，就无法解释相应编码想表达的内容。 终于，有个叫 ISO 的组织看不下去了。他们一起创造了一种编码 UNICODE ，这种编码非常大，大到可以容纳世界上任何一个文字和标志。所以只要电脑上有 UNICODE 这种编码系统，无论是全球哪种文字，只需要保存文件的时候，保存成 UNICODE 编码就可以被其他电脑正常解释。 UNICODE 在网络传输中，出现了两个标准 UTF-8 和 UTF-16，分别每次传输 8个位和 16个位。于是就会有人产生疑问，UTF-8 既然能保存那么多文字、符号，为什么国内还有这么多使用 GBK 等编码的人？因为 UTF-8 等编码体积比较大，占电脑空间比较多，如果面向的使用人群绝大部分都是中国人，用 GBK 等编码也可以。","categories":[],"tags":[]},{"title":"面向对象","slug":"面向对象","date":"2018-06-12T13:07:56.000Z","updated":"2018-06-13T01:08:51.893Z","comments":true,"path":"2018/06/12/面向对象/","link":"","permalink":"http://yoursite.com/2018/06/12/面向对象/","excerpt":"","text":"面向对象 类 : 用来描述具有相同的属性和方法的对象集合.它定义了该集合中每个对象那个所共有的属性和方法 方法 : 类中定义的函数. 类变量 : 类变量在整个实例化的对象中是公用的. 数据成员 : 类变量或者实例. 方法重写 : 如果从父类继承的方法不能满足子类的需求,可以对其改写,这个方法叫做覆盖(override),也称为方法的重写. 类变量实例 : 定义在方法中的变量,只作用于当前的实例的类. 继承 : 即一个派生类derived class 继承 基类 base class 的字段和方法.继承也允许把一个派生类作为一个基类对象对待. 实例化 : 创建一个类的实例. 对象 : 对象是一个类的实例. 类对象 123456789101112131415161718class Myclass: i = 1234 def f(self): return \"hello world\"#类实例化x = Myclass()#访问类的属性和方法print(\"Myclass类的属性 i \" ,x.i)print(\"Myclass类的方法 f \" ,x.f())#运行结果#Myclass类的属性 i 1234#Myclass类的方法 f hello world init 很多类都倾向于将对象创建为有初始状态的。因此类可能会定义一个名为 init() 的特殊方法(构造方法). 类定义了 init() 方法的话，类的实例化操作会自动调用 init() 方法 . init() 方法可以有参数，参数通过 init() 传递到类的实例化操作上 . 1234567891011class Complex: def __init__(self,a,b): self.a = a self.b = bx = Complex(1,2)print(x.a)print(x.b)#运行结果#1#2 self代表类的实例，而非类 12345678910class Test: def prt(self): print(self) print(self.__class__)t = Test() #实例化t.prt()#运行结果#&lt;__main__.Test object at 0x029972F0&gt;#&lt;class '__main__.Test'&gt; 代码中的self其实是可以替换的,只不过大家约定俗成都这样写.同样类的名称首字母也是大写的.","categories":[],"tags":[]},{"title":"桃花源记-中文测试","slug":"桃花源记","date":"2018-06-12T07:00:42.000Z","updated":"2018-06-12T10:08:06.744Z","comments":true,"path":"2018/06/12/桃花源记/","link":"","permalink":"http://yoursite.com/2018/06/12/桃花源记/","excerpt":"","text":"晋太元中，武陵人捕鱼为业。缘溪行，忘路之远近。忽逢桃花林，夹岸数百步，中无杂树，芳草鲜美，落英缤纷，渔人甚异之，复前行，欲穷其林。 林尽水源，便得一山，山有小口，仿佛若有光。便舍船，从口入。初极狭，才通人。复行数十步，豁然开朗。土地平旷，屋舍俨然，有良田美池桑竹之属。阡陌交通，鸡犬相闻。其中往来种作，男女衣着，悉如外人。黄发垂髫，并怡然自乐。 见渔人，乃大惊，问所从来。具答之。便要还家，设酒杀鸡作食。村中闻有此人，咸来问讯。自云先世避秦时乱，率妻子邑人来此绝境，不复出焉，遂与外人间隔。问今是何世，乃不知有汉，无论魏晋。此人一一为具言所闻，皆叹惋。余人各复延至其家，皆出酒食。停数日，辞去。此中人语云：“不足为外人道也。” 既出，得其船，便扶向路，处处志之。及郡下，诣太守，说如此。太守即遣人随其往，寻向所志，遂迷，不复得路。 南阳刘子骥，高尚士也，闻之，欣然规往。未果，寻病终，后遂无问津者。","categories":[],"tags":[]}]}