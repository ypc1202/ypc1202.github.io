{"meta":{"title":"虾米吃大鱼","subtitle":null,"description":null,"author":"ypc1202","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"P0022 进程间通讯","slug":"P0022-进程间通讯","date":"2018-07-11T02:35:27.000Z","updated":"2018-07-11T02:35:54.003Z","comments":true,"path":"2018/07/11/P0022-进程间通讯/","link":"","permalink":"http://yoursite.com/2018/07/11/P0022-进程间通讯/","excerpt":"","text":"阻塞-多进程访问Queue队列 123456789101112131415161718192021222324252627282930from multiprocessing import Queue, Process, current_process#取的时候会不会是一个顺序的def func_get(q): p = current_process() for var in range(50000): ret = q.get() print('%s取到了:%s' % (p.name, ret))def main(): q = Queue() for var in range(150000): q.put(var) #q = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14] p1 = Process(target=func_get, name='p1', args=(q,)) # 0,1,2,3,4 p2 = Process(target=func_get, name='p2', args=(q,)) # 5,6,7,8,9 p3 = Process(target=func_get, name='p3', args=(q,)) p1.start() p2.start() p3.start() p1.join() p2.join() p3.join()# 单核： 涉及不到CPU切换if __name__ == '__main__': main() 阻塞-(Queue)消费者生产者模型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from multiprocessing import Queue, Process, current_processimport timedef get(q): p = current_process() for var in range(10): ret = q.get() print(\"%s get %s\" % (p.name, ret))def put(q): p = current_process() for var in range(10): q.put(var) print(\"%s put %s\" % (p.name, var))def main(): q = Queue() p1 = Process(target=get, name=\"p1\", args=(q,)) p2 = Process(target=put, name=\"p2\", args=(q,)) p1.start() p2.start() p1.join() p2.join()if __name__ == '__main__': main()# p2 put 0# p2 put 1# p1 get 0# p2 put 2# p1 get 1# p2 put 3# p1 get 2# p2 put 4# p1 get 3# p2 put 5# p1 get 4# p2 put 6# p1 get 5# p2 put 7# p1 get 6# p2 put 8# p1 get 7# p2 put 9# p1 get 8# p1 get 9 非阻塞-(Queue)消费者生产者模型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from multiprocessing import Queue, Process, current_processimport time#列表的测试def func_get(q): p = current_process() print('我是子进程:', p.name) for var in range(10): #time.sleep(1) ret = q.get(block=False) # 非阻塞 取不到数据 直接抛出异常queue.Empty异常 #q.get(block=False) q.get_nowait() print('我取到了:', ret) print('***************') #多进程下，进程的顺序是无法控制的def func_put(q): p = current_process() print('我是子进程:', p.name) for var in range(10): #time.sleep(1) q.put_nowait(var) print('我放进去了:', var) print('---------------') #在非阻塞模型下，有先后顺序！ #1:func_get #2:func_putdef main(): q = Queue() p_get = Process(target=func_get, name='拿取进程', args=(q,)) p_put = Process(target=func_put, name='存放进程', args=(q,)) #开启子进程 #CPU执行的顺序 不是你开启进程的顺序 p_put.start() #time.sleep(1) p_get.start() # 反而在取的时候被CPU首先执行 #回收子进程 p_get.join() p_put.join() q.put(1) q.put(1) q.put(1) print(q) #&lt;multiprocessing.queues.Queue object at 0x7f1388bdb4a8&gt; #这个共享队列无法直接看到里面的内容 q.close()if __name__ == '__main__': main() 管道实现生产者消费者 123456789101112131415161718192021222324252627from multiprocessing import Process, Pipeimport pickledef A(pipe): for item in range(10): pipe.send(pickle.dumps(item))def B(pipe): for item in range(10): ret = pickle.loads(pipe.recv()) print(ret)def main(): a, b = Pipe() P1 = Process(target=A, name=\"A\", args=(a,)) P2 = Process(target=B, name=\"B\", args=(b,)) P1.start() # P1不发送 P2会一直阻塞 P2.start() P1.join() P2.join()if __name__ == \"__main__\": main()","categories":[],"tags":[]},{"title":"P0021 进程和线程","slug":"P0021-进程和线程","date":"2018-07-11T02:34:29.000Z","updated":"2018-07-11T02:34:58.545Z","comments":true,"path":"2018/07/11/P0021-进程和线程/","link":"","permalink":"http://yoursite.com/2018/07/11/P0021-进程和线程/","excerpt":"","text":"tags:进程探究进程：这是一个在内存中运行的任务实例 Linux下进程属性： 进程拥有自己独立的PID（身份证号） 0 ~ 65535 PID是有限的 当你一台Linux有了超过65535个进程，第65536个进程 无法启动！ 独立的内存空间，独立的地址。 PID： 0：这个进程是真正的调度进程(idle进程)，是系统初始化的第一个进程，是所有其他进程的祖先！ 1：这个进程是Init进程，后续的系统启动，由0进程创建，第一个子进程，完成剩余的系统引导工作。 2：线程/进程 管理进程 PCB控制块 process control block 进程PCB是用来管理进程，维护进程属性的一个数据块 记录进程中的属性特征，进程的运行状态 没有合法PCB的进程，不会被操作系统所识别管理 PCB进程控制块中主要有以下： 进程标识符 PID。 调度信息：进程优先级 进程状态：挂起，就绪，执行，中断，僵尸。 进程使用的内存空间：文件，套接字（socket），网卡，硬件设备。 处理器信息：计数器，寄存器，指针。 进程的状态： R：就绪/运行 READY RUNNING 实际在CPU上运行的进程，可以被称作运行状态 接下来要执行的进程，处于就绪状态，那么也会被称作R S：可中断睡眠状态 进程去等待资源，等待别人链接，等待读取文件内容，等待打开硬件设备，CPU资源不够用 等待的进程，有专门的任务队列维护，通过一定的事件可以重新激活这些进程进入运行状态R D：不可中断睡眠状态 一般是一些内核进程，Kill -9无法直接杀死，并且无法直接唤醒 这样的进程也处于睡眠状态 这种睡眠状态是为了保护一些硬件资源，保护一些设备。 T：暂停状态 调试程序，打断点 X：停止状态 Z：进程在退出时，必须要经过僵尸状态。 每个进程在退出的时候，都会释放掉内存，但是如果父进程并没有对他做PCB释放， 这个PCB进程控制块就会保留下来，会一致占用PID 僵尸进程： 父进程创建子进程，但是并没有及时回收工作完毕的子进程 没有被释放资源的子进程就会被称作僵尸进程 在于PCB进程控制块无法及时得到释放，所以会导致无法创建新的进程，占用了PID资源。 注意：开发者要注意回收僵尸进程，没人会帮你释放僵尸进程。 孤儿进程： 父进程先结束了 还在执行的子进程没人管了。 孤儿进程就由此诞生了 孤儿进程会被INIT进程接管，然后完成之后，INIT进程帮你回收。 进程状态下一级别： s：进程的会话负责人 &lt;：进程有高优先级 N：进程有低优先级 l：具备多线程的进程 +：位于后台的进程 Nice值：Linux进程优先级 整数 权限：-20 - +19 数字越小，优先级越高 只有超级用户可有把进程优先级设置为负数 VSZ：进程占用的虚拟内存大小 RSS：这个进程占用的固定内存大小 PRI/NI：进程优先级 TTY：打开的虚拟终端 PPID：当前进程的父进程ID COMMAND：开启这个进程的命令 USER：开启进程的用户（表示了当前进程有什么样的权利） F：进程旗标(process flag) 进程的权限 4：ROOT权限 进程 1234567891011121314151617181920212223242526from multiprocessing import Process,current_processimport timeprocessList = []def func(): print(\"我是子进程%s,PID:%s\" %(current_process().name,current_process().pid)) time.sleep(3)def main(): p1 = Process(target = func ,name = \"进程1\") p2 = Process(target = func ,name = \"进程2\") p3 = Process(target = func ,name = \"进程3\") processList = [p1,p2,p3] print(processList) for item in processList: item.start() for item in processList: item.join() # 回收进程资源 可要可不要 不要就是孤儿进程了 #父进程一定会等待全部子进程结束，她才会退出if __name__ == '__main__': main() #父进程有的 #判断当前的 多进程.py 这个脚本如果说是按照模块被别人导入了，那么这个里面的代码不会执行 print('哈哈') #__name__：当前脚本的一个变量， #当你是单独运行这个脚本的时候，她等于__main__ #当你是导入了这个脚本的时候，她等于脚本名 daemon daemon = “True”父进程结束子进程也强行结束 默认daemon = “False”父进程等待子进程结束 123456789101112131415from multiprocessing import Process,current_processimport timedef func(): #我额外开启子进程 她的工作函数 print('我是子进程:',current_process().name) print(\"当前子进程PID:\",current_process().pid) time.sleep(10)def main(): p1 = Process(target=func,name='进程1') #这个进程工作func函数 p1.daemon = True #父进程不会等待子进程结束，并且父进程退出，子进程也会退出 p1.start() time.sleep(5)if __name__ == '__main__': main() 多进程和单线程执行速度对比 12345678910111213141516171819202122232425262728293031323334353637383940414243from multiprocessing import Process,current_processimport timedef func_1(): print('这是第一件事') mysum = 0 for var in range(100000000): mysum += vardef func_2(): print('这是第二件事情') mysum = 1 for var in range(1,100000000): mysum = mysum - vardef func_3(): print('这是第三件事情') mysum = 1 for var in range(100000000): pass #过滤一遍# 单线程# start = time.time()# func_1()# func_2()# func_3()# end = time.time()# print('%.2f' % (end -start))# 多线程 if __name__ == '__main__': p1 = Process(target = func_1, name = \"func1\") p2 = Process(target = func_2, name = \"func2\") p3 = Process(target = func_3, name = \"func3\") start = time.time() p1.start() p2.start() p3.start() p1.join() # 确保 P1执行完才向下进行 p2.join() # 确保 P2执行完才向下进行 p3.join() # 确保 P3执行完才向下进行 end = time.time() print('%.2f' % (end -start))","categories":[],"tags":[]},{"title":"P0020 python和pip安装","slug":"P0020-python和pip安装","date":"2018-07-07T06:25:49.000Z","updated":"2018-07-09T11:48:42.313Z","comments":true,"path":"2018/07/07/P0020-python和pip安装/","link":"","permalink":"http://yoursite.com/2018/07/07/P0020-python和pip安装/","excerpt":"","text":"Linux简单命令: ls 展示当前目录下的文件及文件夹 windows：dir命令 cd:指定一个路径 进入 \\ cat查看文件内容 tar -zxvf Python-3.6.2.tgz解压压缩包 mkdir创建目录 sudo都是一些超级用户的权限来执行 yum install 安装软件包名 yum remove删除一个软件包 linux安装Python3linux: ifconfigCMD: ipconfig源码安装：Python 3.6.2.tgz 首先安装依赖 yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel 解压压缩包 tar -zxvf Python-3.6.2.tgz 进入压缩包 cd Python-3.6.2/ 创建安装目录 mkdir /usr/local/python3 指明安装路径 ./configure -prefix=/usr/locall/python3 编译、安装 sudo make &amp;&amp; make install 为python3创建软连接 ln -s /usr/local/python3/bin/python3 /usr/bin/python3 为pip3创建软连接 ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 创建软连接 必须使用绝对路径 pip可以很方便的为我们的python安装模块，安装框架 模块管理工具 pip3 -V查看当前的pip版本及pip属于哪个python pip3 install bs4 如果安装报错需要执行下面的操作 安装报错，缺失依赖库 1234567891011121314151617[root@localhost Python-3.6.1]# ./configure checking build system type... x86_64-unknown-linux-gnuchecking host system type... x86_64-unknown-linux-gnuchecking for python3.6... nochecking for python3... nochecking for python... pythonchecking for --enable-universalsdk... nochecking for --with-universal-archs... nochecking MACHDEP... linuxchecking for --without-gcc... nochecking for --with-icc... nochecking for gcc... nochecking for cc... nochecking for cl.exe... noconfigure: error: in `/root/Python-3.6.1':configure: error: no acceptable C compiler found in $PATHSee `config.log' for more details 安装依赖库 1[root@localhost Python-3.6.1]# yum install gcc 安装python3.6 1[root@localhost Python-3.6.1]# make &amp;&amp; make install make &amp;&amp; make install 报错 zipimport.ZipImportError: can’t decompress data; zlib not availablemake: *** [install] Error 1 安装zlib-devel 1[root@localhost Python-3.6.1]# yum install zlib-devel 重新安装 1[root@localhost Python-3.6.1]# make &amp;&amp; make install pip升级 pip install --upgrade pip或者pip3 install --upgrade pip","categories":[],"tags":[]},{"title":"P0019 集合","slug":"P0019-集合","date":"2018-07-05T13:36:57.000Z","updated":"2018-07-05T13:36:57.473Z","comments":true,"path":"2018/07/05/P0019-集合/","link":"","permalink":"http://yoursite.com/2018/07/05/P0019-集合/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"P0018 元组","slug":"P0018-元组","date":"2018-07-05T13:20:29.000Z","updated":"2018-07-05T13:36:41.557Z","comments":true,"path":"2018/07/05/P0018-元组/","link":"","permalink":"http://yoursite.com/2018/07/05/P0018-元组/","excerpt":"","text":"123456789101112# 要创建简单的数据结构,可以使用元组将一组值打包到一个对象中.stock = ('GOOG', 1000, 490,10)address = (\"www.python.org\",80)stock = 'GOOG', 1000, 490,10 # 不加括号也可以是创建元组address = \"www.python.org\",80print(type(stock)) # &lt;class 'tuple'&gt;Tuple = (1,2,3,4,(1,2,3,4,(1,2,3,4)))print(Tuple[0])print(Tuple[4])print(Tuple[4][4])","categories":[],"tags":[]},{"title":"P0017 列表","slug":"P0017-列表","date":"2018-07-05T12:29:56.000Z","updated":"2018-07-05T13:20:03.260Z","comments":true,"path":"2018/07/05/P0017-列表/","link":"","permalink":"http://yoursite.com/2018/07/05/P0017-列表/","excerpt":"","text":"列表是任意对象的组成序列.把值放入方括号中就可以创建列表 123456789101112131415161718192021# 列表是任意对象的组成序列.把值放入方括号中就可以创建列表List = [1,\"a\",[1,\"b\"],(3,4),&#123;1:2,3:4&#125;]print(List)print(type(List[0]))print(type(List[1]))print(type(List[2]))print(type(List[3]))print(type(List[4]))List.append(\"Jeff\")print(List)List.insert(2,\"Thomas\") # 插到2位置,原来二位置向后退1print(List)List = List + List # 列表拼接print(List)if bytes is str: print(\"True\")else: print(\"False\")","categories":[],"tags":[]},{"title":"P0016 字符串","slug":"P0016-字符串","date":"2018-07-04T11:52:39.000Z","updated":"2018-07-09T11:48:34.003Z","comments":true,"path":"2018/07/04/P0016-字符串/","link":"","permalink":"http://yoursite.com/2018/07/04/P0016-字符串/","excerpt":"","text":"字符串创建方法 1234567891011121314151617a = 'Hello World'b = \"Python is groovy\"c = \"\"\"Computer says no\"\"\"d = \"\"\"123\\ 456\\ 789\"\"\"e = \"\"\"123456789\"\"\"print(a) # Hello Worldprint(b) # Python is groovyprint(c) # Computer says noprint(d) # 123 456 789print(e)# 123# 456# 789 字符串索引 12345678910a = 'Hello World'print(a[0]) # 打印Hprint(a[0:]) # 全部print(a[:]) # 全部print(a[::1]) # 全部print(a[::2]) # 从0开始步长位2访问print(a[::-1]) # 逆序print(\"=============\")print(a[-len(a):]) # 正常输出print(a[::-4]) # 逆序步长 字符串函数 1234567# str()和repr()都可以船舰字符串str()和print输出的相同,repr船舰的字符串可以表示程序中某个对象的精确值(我是出来好像没什么屌用)x = 3.4print(x)str(x) # 直接修改变量数据类型print(x)print(type(x))print(repr(x)) 字符串内置函数 string.capitalize() : 字符串的第一个字母大写 12&gt;&gt;&gt; \"hello world\".capitalize()'Hello world' string.center(width) : 返回一个共 width 列、填充空格的字符串，原始字符串处于其中心位置 12&gt;&gt;&gt; \"123\".center(10)' 123 ' string.count(str, beg=0, end=len(string)) : 统计 str 在 string 中出现的次数，如果给定了开始索引 beg 和结束索引 end，将统计 str 在 string 的子串中出现的次数 1234&gt;&gt;&gt; \"yanpengcheng\".count(\"y\")1&gt;&gt;&gt; \"yanpengcheng\".count(\"g\")2 string.decode(encoding=’UTF-8, ‘errors=’strict’)返回 string 的解码字符串版本；如果发生错误，默认情况下会抛出一个ValueError 异常，除非通过 ignore 或 replace 给出了 errors 12&gt;&gt;&gt; b&quot;1&quot;.decode(encoding=&quot;UTF-8&quot;)&apos;1&apos; string.encode(encoding=’UTF-8’, ‘errors=’strict ‘)返回 string 的编码字符串版本；如果发生错误，默认情况下会抛出一个ValueError 异常，除非通过 ignore 或 replace 给出了 errors 12&gt;&gt;&gt; \"1\".encode(encoding=\"UTF-8\")b'1'","categories":[],"tags":[]},{"title":"P0015 内置函数","slug":"P0015-内置函数","date":"2018-07-04T07:58:18.000Z","updated":"2018-07-05T09:57:24.759Z","comments":true,"path":"2018/07/04/P0015-内置函数/","link":"","permalink":"http://yoursite.com/2018/07/04/P0015-内置函数/","excerpt":"","text":"format() 123456789printcipal = 0.1234year = 2018 print(format(year,\"3d\"),format(printcipal, \"0.2f\"))print(\"&#123;0:3d&#125; &#123;1:0.2f&#125;\".format(year,printcipal))print(\"%3d %0.2f\" % (year,printcipal))# 2018 0.12# 2018 0.12# 2018 0.12","categories":[],"tags":[]},{"title":"P0014 华为打印机面试题","slug":"P0014-华为打印机面试题","date":"2018-07-04T07:00:19.000Z","updated":"2018-07-04T07:03:50.051Z","comments":true,"path":"2018/07/04/P0014-华为打印机面试题/","link":"","permalink":"http://yoursite.com/2018/07/04/P0014-华为打印机面试题/","excerpt":"","text":"12345678910111213输入一个任务队列从0到9，数字越大，优先级越高执行的任务顺序对应的索引打印出来如果取出来的任务，比之后的任务优先级要小，那么要把这个取出来的任务先放到整个任务队列**最后**index,value = enumerate(): 返回对应数据及数据所对应的索引值index:数据索引value:对应数据15分钟解决输入:9,1,3,5,5,7,8 #任务队列输出:0,6,5,3,4,2,1 #打印的是原始任务里的索引值 12345list1 = [9,1,3,5,5,7,8]list2 = (list(zip(list1,list(range(len(list1))))))list3 = sorted(list2,key=lambda x:(x[0]),reverse = True)print(\"整理过后任务序列list\",list(zip(*list3))[0])print(\"打印引索\",list(zip(*list3))[1])","categories":[],"tags":[]},{"title":"P0013 多态","slug":"P0013-多态","date":"2018-07-04T06:58:50.000Z","updated":"2018-07-04T06:59:21.844Z","comments":true,"path":"2018/07/04/P0013-多态/","link":"","permalink":"http://yoursite.com/2018/07/04/P0013-多态/","excerpt":"","text":"1234567891011121314151617181920212223242526class Water: def use(self): print(\"喝水\")class Water_cook(Water): def use(self): print('做饭')class Water_Shower(Water): def use(self): print('洗澡')def cost_water(obj): if isinstance(obj,Water): #判断传入参数必须是水 obj.use() else: print('不是水，不能用') a = Water()b = Water_cook()c = Water_Shower()# a == b == c 同类 但是同样函数 不同功能 多态# 多态是继承重写，所以说对于代码来说，风格代码cost_water(a)cost_water(b)cost_water(c)","categories":[],"tags":[]},{"title":"P0012 切片函数重写","slug":"P0012-切片函数重写","date":"2018-07-04T06:56:55.000Z","updated":"2018-07-04T06:57:33.636Z","comments":true,"path":"2018/07/04/P0012-切片函数重写/","link":"","permalink":"http://yoursite.com/2018/07/04/P0012-切片函数重写/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class myList2(list): #我们自定义个索引从1开始的。 def __getitem__(self,*args): # print(args) #偷偷看下args长什么样子 ''' slice这个类型三个属性 start -- 起始位置 ,stop -- 结束位置,step -- 间距 ''' start = args[0].start stop = args[0].stop step = args[0].step selfLen = len(self) newList = myList2([]) if step == None: step = 1 if step &gt; 0: #判断步长大于零，即正序 if start == None: start = 0 if stop == None: stop = selfLen if start &gt;= selfLen: return myList2([]) else: if start &lt; -selfLen: start = -selfLen if stop &gt; selfLen: stop = selfLen index = start if index &gt;= 0: if stop &lt; 0: stop = selfLen + stop while index &lt; stop: newList.append(super().__getitem__(index)) index += step return newList else: if stop &gt; 0: stop = -(selfLen - stop) while index &lt; stop: newList.append(super().__getitem__(index)) index += step return newList elif step &lt; 0:#判断步长小于零，即逆序 if start == None: start = selfLen if stop == None: stop = -(selfLen+1) if start &lt; -selfLen: return myList2([]) else: if start &gt;= selfLen: start = selfLen - 1 if stop &lt; -(selfLen + 1) : stop = -(selfLen+1) index = start if index &gt;= 0: if stop &lt; 0: stop = selfLen + stop while index &gt; stop: newList.append(super().__getitem__(index)) index += step return newList else: if stop &gt; 0: stop = -(selfLen - stop) while index &gt; stop: newList.append(super().__getitem__(index)) index += step return newList else: raise ValueError('step cannot be zero!') b = myList2([1,2,3,4,5,6,7,8,9,10])print(b[:1:])c = [1,2,3,4,5,6]print(c[:1:])","categories":[],"tags":[]},{"title":"P0011 装饰器","slug":"P0011-装饰器","date":"2018-07-04T06:50:20.000Z","updated":"2018-07-11T01:38:19.123Z","comments":true,"path":"2018/07/04/P0011-装饰器/","link":"","permalink":"http://yoursite.com/2018/07/04/P0011-装饰器/","excerpt":"","text":"1234567@tracedef square(x): return x*x# 上面的代码是下面代码的简化:def square(x): return x*xsquare = trace(square) 1234567enableTracing = Trueif enableTracing: debugLog = open(&quot;debug.log&quot;,&quot;w&quot;)def trace(func): if enableTracing: def callf(*args,**kwargs): Example1:简单的装饰器 123456789101112def wai(obj): def nei(): print(\"这是增加的功能\") return obj() return nei@waidef func(): print(\"这是原始的功能\") return \"哈*3\"print(func()) Example2:被装饰函数带参数 123456789101112# 海拔装饰def dlevation(obj): def wrapper(temp): return obj(temp + 100) return wrapper@dlevationdef tree(temp): return tempres = tree(123)print(res) Example3:装饰器函数带参数 1234567891011121314151617181920212223242526enableTracing = Trueif enableTracing: debugLog = open(\"debug.log\",\"w\")def trace(func): if enableTracing: def callf(*args,**kwargs): debugLog.write(\"Calling %s: %s,%s \\n\" % (func.__name__, args,kwargs)) r = func(*args,**kwargs) debugLog.write(\"%s returned %s\\n\" % (func.__name__, r)) debugLog.close() return r return callf else: return func@tracedef square(*args,**kwargs): print(1)square(1,2,3,a = 1,b = 2,c =3)#Calling square: (1, 2, 3),&#123;'c': 3, 'a': 1, 'b': 2&#125; #square returned None","categories":[],"tags":[]},{"title":"P0010 迭代器","slug":"P0010-迭代器","date":"2018-07-04T06:48:19.000Z","updated":"2018-07-04T06:48:58.335Z","comments":true,"path":"2018/07/04/P0010-迭代器/","link":"","permalink":"http://yoursite.com/2018/07/04/P0010-迭代器/","excerpt":"","text":"12345678910111213141516171819202122232425import itertoolsimport timea = itertools.count()mylist = [1,2,3]b = itertools.cycle(mylist)# for实现无限循环# for var in b:# time.sleep(1)# print(var)a = [1,2,3,4,5]res = iter(a)print(next(res))print(next(res))print(next(res))print(next(res))print(next(res))# print(next(res))# print(next(res)# 可迭代对象和迭代器# 只要有iter 就可以被iter加工 然后通过next 或for访问现金和","categories":[],"tags":[]},{"title":"P0009 函数传参","slug":"P0009-函数传参","date":"2018-07-04T06:46:29.000Z","updated":"2018-07-04T06:48:04.340Z","comments":true,"path":"2018/07/04/P0009-函数传参/","link":"","permalink":"http://yoursite.com/2018/07/04/P0009-函数传参/","excerpt":"","text":"123456789101112def func(a = 0, b = 0, *args, **kwargs): print(\"a:\",a) print(\"b:\",b) print(\"args:\",args) print(\"kwargs:\",kwargs)func(1, 2, 3, 4, 5, 6, c = 13)# a: 1# b: 2# args: (3, 4, 5, 6)# kwargs: &#123;'c': 13&#125;","categories":[],"tags":[]},{"title":"P0008 推导式","slug":"P0008-推导式","date":"2018-07-04T06:32:21.000Z","updated":"2018-07-04T06:42:45.568Z","comments":true,"path":"2018/07/04/P0008-推导式/","link":"","permalink":"http://yoursite.com/2018/07/04/P0008-推导式/","excerpt":"","text":"类表推导式 打印0~9的平方。 1print([x * x for x in range(10)]) # =&gt; [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 打印0~6的平方。 1print([x * x for x in range(10) if x &lt; 7]) # =&gt; [0, 1, 4, 9, 16, 25, 36] 将列表里小于等于20000数据全部加1000。 1234salary_list = [13000,12700,15000,14000,25000,16000,18000,22000,32000]res = [ var + 1000 for var in salary_list if var &lt;= 20000 ]salary_list[:len(res)] = resprint(res) 字典推导式 将字典key和value交换 123DictIn=&#123;\"a\":1, \"b\":2, \"c\":3, \"d\":4&#125;DictOut=&#123;v:k for k,v in DictIn.items()&#125;print(DictOut) # =&gt; &#123;1: 'a', 2: 'b', 3: 'c', 4: 'd'&#125; 集合推导式 集合推导式跟列表推导式差不多，都是对一个列表的元素全部执行相同的操作， 但集合是一种无重复无序的序列 区别：跟列表推到式的区别在于：1.不使用中括号，使用大括号；2.结果中无重复；3.结果是一个set()集合，集合里面是一个序列 12squared = &#123; i * 2 for i in [1, 1, 2]&#125;print(squared) # =&gt; &#123;2, 4&#125;","categories":[],"tags":[]},{"title":"P0007 删除文件和文件夹","slug":"P0007-删除文件和文件夹","date":"2018-07-04T06:32:08.000Z","updated":"2018-07-04T06:42:24.191Z","comments":true,"path":"2018/07/04/P0007-删除文件和文件夹/","link":"","permalink":"http://yoursite.com/2018/07/04/P0007-删除文件和文件夹/","excerpt":"","text":"12345678910111213141516171819import osdef func(path): if os.path.exists(path): for item in os.listdir(path): item = os.path.join(path, item) if os.path.isdir(item): func(item) else: os.remove(item) os.removedirs(path) # 当进入一个文件夹下发现item为空,直接把文件夹删除. else: raise TypeError(\"路径错误!\")# print(help(os.path.exists)/)path = input(\"请输入路径:\")func(path)","categories":[],"tags":[]},{"title":"P0006 切片和深浅拷贝","slug":"P0006-切片和深浅拷贝","date":"2018-07-04T06:31:40.000Z","updated":"2018-07-04T06:41:36.379Z","comments":true,"path":"2018/07/04/P0006-切片和深浅拷贝/","link":"","permalink":"http://yoursite.com/2018/07/04/P0006-切片和深浅拷贝/","excerpt":"","text":"不可变数据的片选深浅拷贝 123456789101112131415161718192021222324import copystr1 = \"hello world\"str2 = str1str3 = str1[:]str4 = copy.copy(str1)str5 = copy.deepcopy(str1)print(id(str1)) # 97509688print(id(str2)) # 97509688print(id(str3)) # 97509688print(id(str4)) # 97509688print(id(str5)) # 97509688str1 = \"hello china\"print(str1) # hello chinaprint(str2) # hello worldprint(str3) # hello worldprint(str4) # hello worldprint(str5) # hello worldprint(id(str1)) # 97509728print(id(str2)) # 97509688print(id(str3)) # 97509688print(id(str4)) # 97509688print(id(str5)) # 97509688 不可变数据的片选 可变数据的片选深浅拷贝 12345678910111213141516171819202122232425import copylist1 = [1, 2, 3, [4, 5, 6, [7, 8, 9]]]list2 = list1list3 = list1[:]list4 = copy.copy(list1)list5 = copy.deepcopy(list1)print(id(list1)) # 96760976print(id(list2)) # 96760976print(id(list3)) # 96718120print(id(list4)) # 95303320print(id(list5)) # 96760336list1[0] = 'a'list1[3][0] = 'a'print(list1) # ['a', 2, 3, ['a', 5, 6, [7, 8, 9]]]print(list2) # ['a', 2, 3, ['a', 5, 6, [7, 8, 9]]]print(list3) # [1, 2, 3, ['a', 5, 6, [7, 8, 9]]]print(list4) # [1, 2, 3, ['a', 5, 6, [7, 8, 9]]]print(list5) # [1, 2, 3, [4, 5, 6, [7, 8, 9]]]print(id(list1)) # 96760976print(id(list2)) # 96760976print(id(list3)) # 96718120print(id(list4)) # 95303320print(id(list5)) # 96760336 列表切头操作 12345678910111213141516171819list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]for item in list1: if(len(list1) &gt;= 2): list1 = list1[1:] print(str(list1)+(10-len(list1))*3*\" \"+str(id(list1))) # [2, 3, 4, 5, 6, 7, 8, 9, 10] 84309656# [3, 4, 5, 6, 7, 8, 9, 10] 84310016# [4, 5, 6, 7, 8, 9, 10] 84309656# [5, 6, 7, 8, 9, 10] 84310016# [6, 7, 8, 9, 10] 84309656# [7, 8, 9, 10] 84310016# [8, 9, 10] 84309656# [9, 10] 84310016# [10] 84309656# 问:好奇为什么列表地址会有相同的?# 亳州-二狗-sql维护答:因为砍头操作不是删元素，赋值操作结束之后原列表被覆盖. 列表切屁股操作 1234567891011121314151617list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]for item in list1: if(len(list1) &gt;= 2): list1 = list1[:-1] print(str(list1)+(10-len(list1))*3*\" \"+str(id(list1))) # print(id(list1))# [1, 2, 3, 4, 5, 6, 7, 8, 9] 93943488# [1, 2, 3, 4, 5, 6, 7, 8] 93943848# [1, 2, 3, 4, 5, 6, 7] 93943488# [1, 2, 3, 4, 5, 6] 93943848# [1, 2, 3, 4, 5] 93943488# [1, 2, 3, 4] 93943848# [1, 2, 3] 93943488# [1, 2] 93943848# [1] 93943488 片选 一道公司的面试题”给出随机的一段字符,当遇到”\\n”时,抛弃之前的字符,输出”\\n”之后的字符,例如cadddd\\nasdas\\nfasadas,应输出fasadas. 12aas = \"cadddd\\nasdas\\nfasadas\"print(aas[-aas[::-1].find(\"\\n\"):])","categories":[],"tags":[]},{"title":"P0005 面向对象属性","slug":"P0005-面向对象属性","date":"2018-07-04T06:31:25.000Z","updated":"2018-07-04T06:41:01.570Z","comments":true,"path":"2018/07/04/P0005-面向对象属性/","link":"","permalink":"http://yoursite.com/2018/07/04/P0005-面向对象属性/","excerpt":"","text":"1234567891011121314class Human: number = 0 def __init__(self,name): Human.number += 1 self.name = namehuman1 = Human(\"小红\") human2 = Human(\"小芳\")print(human1.number) # 类变量可以被实例和类同时访问 # =&gt; 2human2.number = 10print(Human.number) # =&gt; 2human3 = Human(\"小白\")print(human2.number) # =&gt; 10print(Human.number) # =&gt; 3 变量 实例的变量：只能被实例所访问(私有) 实例的变量可以被实例所使用 human1.name 实例.的方式来获取到属于实例的私有变量 属于实例的self.xxx 这样子的变量是无法通过类来直接访问的。因为这些属性需要实例化 self.xxx这样子的变量 是我的实例所私有的 类的变量：可以被实例，类同时访问(共享) 但是如果实例修改或者重新赋值了类的变量，那么这个变量将升级为私有的 如果这个变量没有提前出现过，我也赋值定义修改了，那么也会变成这个实例独有的。 内部的是独立私有的，外部的是大家公用的(共享) 类和实例均支持在创建之后，存活期间动态的添加新的属性 实例添加的时候，如果你只为一个单独实例添加，那么其他实例是不会有的 类添加的时候，大家都有 方法(函数) 实例的方法：只能被实例所调用，而且默认实例方法第一个位置上的参数，必须传递调用实 例！ def func(self)… xx.func 来调用一个实例函数，那么实例一定会作为第一个参数传递进来 函数中的self也可以让我们方便的直接获取到属于实例的私有变量 实例函数中可以访问其他实例属性：因为self来指向当前实例中的其他属性,self.other 123456789101112131415161718192021222324252627282930313233343536373839import randomclass Car: carNumber = 0 carList = [] colorList = [\"BALCK\",\"BLUE\",\"RED\"] def __init__(self,name): self.name = name #车的名字 self.gas = 0 #车的油量 self.colour = random.choice(Car.colorList) #车的颜色 choices是带括号的 # print(self.colour) Car.carNumber += 1 Car.carList.append(self) def changeColour(self,colour): print(\"%s改变颜色为:%s\" % (self.name,colour)) self.colour = colour def run(self): # 车子会跑 if self.gas &lt;= 0: print('%s车没油',self.name) else: print('%s跑了10Mile,消耗的1升汽油' % self.name) self.gas = self.gas - 10 #跑一次少10升 print(\"%s当前流量:%d\" % (self.name,self.gas)) def addGas(self,oil_num): #加油 self.gas += oil_num #加到油 print('%s加完油了,现在油量位:%d'%(self.name,self.gas)) car1 = Car('Ford')car2 = Car('Jaguar')car3 = Car('Mazda')# print(dir(random))# print(help(random.choices))# print(help(random.choice))for item in Car.carList: print(\"汽车的品牌为:%s,汽车的颜色为%s\" %(item.name,item.colour)) 类的方法 类的普通函数 权限完全封闭 啥都别想看 只能被类所使用，实例访问不了这种函数 不能访问类变量以及实例变量 123456789101112class A: place = '地球' def __init__(self): self.name = '哈哈哈' def func(): #函数没有任何参数 #类的普通函数 print(\"啊哈哈哈哈哈哈\")a = A()# a.func() #普通类方法 无法被实例调用A.func() #普通类方法，只能被类调用 类的高级函数 权限展开了类的变量访问权限 实例和类均可调用 可以访问属于类的变量 不可以访问属于实例的属性 你有了cls之后，也就可以互相指向到其他类中高级函数，也就可以调用了 可以在另外一个类中高级函数调用其他类的高级函数 1234567891011121314class A: place = '地球' @classmethod def g_func(cls): #默认的必须要有一个参数， #cls参数用来指向当前的类! print(cls.place) @classmethod def g_func1(cls): #默认的必须要有一个参数， cls.g_func()a = A()a.g_func() # =&gt; 地球a.g_func1() # =&gt; 地球 在这里，必须为类的高级函数第一个参数约定俗称的写一个cls形参 该形参用来接收使用的类 类的静态方法：开放了实例访问函数的权限，但是变量的权限访问(访问类、实例变量)全部关闭 首先无法访问属于类的变量，没有指向当前使用类的指针 实例和类均可调用 不可以访问属于实例的属性 1234567891011class A: @staticmethod #类似与类的普通函数 #不需要cls这样的额外参数 def s_func(): print('哈哈哈哈哈') #和我类数据无关的操作a = A()a.s_func() # =&gt; 哈哈哈哈哈A.s_func() # =&gt; 哈哈哈哈哈 实例之间可以通过静态方法@staticmethod以及高级类方法@classmethod可以进行数据通信 C++里面静态方法：共享，通信 cls用来指向类self用来指向实例","categories":[],"tags":[]},{"title":"P0004 面向对象","slug":"P0004-面向对象","date":"2018-07-04T06:31:02.000Z","updated":"2018-07-04T06:40:40.611Z","comments":true,"path":"2018/07/04/P0004-面向对象/","link":"","permalink":"http://yoursite.com/2018/07/04/P0004-面向对象/","excerpt":"","text":"面向对象 类 : 用来描述具有相同的属性和方法的对象集合.它定义了该集合中每个对象那个所共有的属性和方法 方法 : 类中定义的函数. 类变量 : 类变量在整个实例化的对象中是公用的. 数据成员 : 类变量或者实例. 方法重写 : 如果从父类继承的方法不能满足子类的需求,可以对其改写,这个方法叫做覆盖(override),也称为方法的重写. 类变量实例 : 定义在方法中的变量,只作用于当前的实例的类. 继承 : 即一个派生类derived class 继承 基类 base class 的字段和方法.继承也允许把一个派生类作为一个基类对象对待. 实例化 : 创建一个类的实例. 对象 : 对象是一个类的实例. 类对象 123456789101112131415161718class Myclass: i = 1234 def f(self): return \"hello world\"#类实例化x = Myclass()#访问类的属性和方法print(\"Myclass类的属性 i \" ,x.i)print(\"Myclass类的方法 f \" ,x.f())#运行结果#Myclass类的属性 i 1234#Myclass类的方法 f hello world init 很多类都倾向于将对象创建为有初始状态的。因此类可能会定义一个名为 init() 的特殊方法(构造方法). 类定义了 init() 方法的话，类的实例化操作会自动调用 init() 方法 . init() 方法可以有参数，参数通过 init() 传递到类的实例化操作上 . 1234567891011class Complex: def __init__(self,a,b): self.a = a self.b = bx = Complex(1,2)print(x.a)print(x.b)#运行结果#1#2 self代表类的实例，而非类 12345678910class Test: def prt(self): print(self) print(self.__class__)t = Test() #实例化t.prt()#运行结果#&lt;__main__.Test object at 0x029972F0&gt;#&lt;class '__main__.Test'&gt; 代码中的self其实是可以替换的,只不过大家约定俗成都这样写.同样类的名称首字母也是大写的.","categories":[],"tags":[]},{"title":"P0003 OS文件操作","slug":"P0003-OS文件操作","date":"2018-07-04T06:30:44.000Z","updated":"2018-07-04T06:40:18.360Z","comments":true,"path":"2018/07/04/P0003-OS文件操作/","link":"","permalink":"http://yoursite.com/2018/07/04/P0003-OS文件操作/","excerpt":"","text":"获取输入路径下文件的个数和大小 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import osclass fileProcess: def __init__(self): self.path = None self.fileList = [] self.fileAllSize = 0 self.unitList = [\"B\", \"kB\", \"MB\", \"GB\", \"TB\"] def getFileNumber(self, path): if os.path.exists(path): for name in os.listdir(path): name = os.path.join(path, name) if os.path.isdir(name): self.getFileNumber(name) else: self.fileList.append(name) # print(name) else: raise TypeError(\"路径输入错误!\") def getFileSize(self, path): if os.path.exists(path): for name in os.listdir(path): name = os.path.join(path, name) if os.path.isdir(name): self.getFileSize(name) else: self.fileAllSize += os.path.getsize(name) else: raise TypeError(\"路径输入错误!\") def uintChange(self): index = len(self.unitList) while True: if self.fileAllSize &lt; 1024: print(\"文件大小为%dbytes\" % self.fileAllSize) break else: if self.fileAllSize &gt; 1024 ** index: print(\"文件总大小为:%.2f%s\" % (self.fileAllSize / 1024 ** index, self.unitList[index])) break else: index -= 1fileP = fileProcess()# C:\\Users\\Administrator\\Desktop\\winhex# a.getFileNumber(input(\"请输入要获取的文件路径:\"))fileP.path = input(\"请输入要获取的文件路径:\")fileP.getFileSize(fileP.path)fileP.getFileNumber(fileP.path)print(\"文件数量:%d\" % len(fileP.fileList))fileP.uintChange()","categories":[],"tags":[]},{"title":"P0002 Python查看源码","slug":"P0002-Python查看源码","date":"2018-07-04T06:30:18.000Z","updated":"2018-07-04T06:39:59.604Z","comments":true,"path":"2018/07/04/P0002-Python查看源码/","link":"","permalink":"http://yoursite.com/2018/07/04/P0002-Python查看源码/","excerpt":"","text":"如何查看外部模块在哪以及如何打印出源代码? 1234import random print(random.__file__) # =&gt; D:\\Program Files (x86)\\Python36-32\\lib\\random.pywith open(str(random.__file__),\"r\") as f: print (f.read()) 最简单就安装VSCode.","categories":[],"tags":[]},{"title":"P0001 阶段考试","slug":"P0001-阶段考试","date":"2018-07-04T06:29:59.000Z","updated":"2018-07-04T06:39:44.453Z","comments":true,"path":"2018/07/04/P0001-阶段考试/","link":"","permalink":"http://yoursite.com/2018/07/04/P0001-阶段考试/","excerpt":"","text":"##### 123456789101112131415161718192021小Q翻转(腾讯)小Q定义了一种数列称为翻转数列:给定整数n和m, 满足n能被2m整除。对于一串连续递增整数数列1, 2, 3, 4..., 每隔m个符号翻转一次, 最初符号为&apos;-&apos;;。例如n = 8, m = 2, 数列就是: -1, -2, +3, +4, -5, -6, +7, +8.而n = 4, m = 1, 数列就是: -1, +2, -3, + 4.小Q现在希望你能帮他算算前n项和为多少。输入描述:输入包括两个整数n和m(2 &lt;= n &lt;= 109, 1 &lt;= m), 并且满足n能被2m整除。输出描述:输出一个整数, 表示前n项和。输入:8(n) 2(m)输出:8(和值) 答案: 12345678910111213141516171819202122232425262728def func(): step = 1 flag = 0 m = int(input(\"请输入m:\")) if m &lt; 1: print(\"m输入范围请重新输入!\") return n = int(input(\"请输入n:\")) if n &lt;= 1 or n &gt; 109: print(\"n输入范围请重新输入!\") return # print(m) # print(n) list1 = sorted(list(range(- n, 0)), reverse=1) print(list1) while True: for item in range(0, m): if (m * step + item) &gt;= n: flag = 1 break list1[m * step + item] = (-1) * list1[m * step + item] step += 2 if flag: break print(sum(list1))func() ##### 123456789101112131415小Q吃巧克力(腾讯)小Q的父母要出差N天，走之前给小Q留下了M块巧克力。小Q决定每天吃的巧克力数量不少于前一天吃的一半，但是他又不想在父母回来之前的某一天没有巧克力吃，请问他第一天最多能吃多少块巧克力输入描述:每个输入包含一个测试用例。每个测试用例的第一行包含两个正整数，表示父母出差的天数N和巧克力的数量M输出描述:输出一个数表示小Q第一天最多能吃多少块巧克力。输入:3(父母出差天数) 7(巧克力总数)输出:4(第一天最多吃的数量) 答案: 1234567891011121314151617181920def func(): flag = 0 m = int(input(\"请输入出差天数M:\")) n = int(input(\"请输入巧克力个数N:\")) for item in (range(n, 0, -1)): # print(item) if flag == 1: break num = item for index in range(0, m): num += num / 2 if num &gt;= n: break else: flag = 1 print(item) breakfunc() ##### 123456789101112131415161718袋鼠过河(网易)一只袋鼠要从河这边跳到河对岸，河很宽，但是河中间打了很多桩子，每隔一米就有一个，每个桩子上都有一个弹簧，袋鼠跳到弹簧上就可以跳的更远。每个弹簧力量不同，用一个数字代表它的力量，如果弹簧力量为5，就代表袋鼠下一跳最多能够跳5米，如果为0，就会陷进去无法继续跳跃。河流一共N米宽，袋鼠初始位置就在第一个弹簧上面，要跳到最后一个弹簧之后就算过河了，给定每个弹簧的力量，求袋鼠最少需要多少跳能够到达对岸。如果无法到达输出-1输入描述:输入分两行，第一行是河岸宽度第二行是每一个木桩的弹簧力量输出描述:输出最少的跳数，无法到达输出-1输入:52 0 1 1 1输出:4 答案: 1234567891011121314151617181920212223def func(): m = int(input(\"河岸宽度:\")) if m == 0: print(\"长度输入错误\") return 0 list1 = list((input(\"每一个木桩的弹簧力量:\").replace(\" \", \"\"))) print(list1) if len(list1) != m: print(\"输入错误\") return 0 index = int(list1[0]) cnt = 0 while True: if index &gt;= m: print(cnt + 1) return 1 if int(list1[index]) == 0: print(\"无法到达!\") return -1 else: index += int(list1[index]) cnt += 1func()","categories":[],"tags":[]},{"title":"A0007 编码参考资料","slug":"A0007-编码参考资料","date":"2018-07-04T06:29:31.000Z","updated":"2018-07-04T06:35:54.378Z","comments":true,"path":"2018/07/04/A0007-编码参考资料/","link":"","permalink":"http://yoursite.com/2018/07/04/A0007-编码参考资料/","excerpt":"","text":"编码 默认情况下python3的源码文件以UTF-8编码,所有字符串都是unicode字符串. 此处参考https://wenku.baidu.com/view/cb9fe505cc17552707220865.html ​ 很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为”字节“。再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机“。 ​ 开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作： 遇上0×10, 终端就换行； 遇上0×07, 终端就向人们嘟嘟叫； 遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。 他们看到这样很好，于是就把这些0×20以下的字节状态称为”控制码”。他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 ​ 后来，就像建造巴比伦塔一样，世界各地都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用 127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128 到255这一页的字符集被称”扩展字符集“。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！ ​ 等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312“。GB2312 是对 ASCII 的中文扩展。 ​ 但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把GB2312 没有用到的码位找出来老实不客气地用上。后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK包括了GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS“（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍： “一个汉字算两个英文字符！一个汉字算两个英文字符……” ​ 因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，像是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 真是计算机的巴比伦塔命题啊！ ​ 正在这时，大天使加百列及时出现了——一个叫 ISO（国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号 的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “unicode“。 ​ unicode开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ASCII里的那些“半角”字符，unicode包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。 ​ 这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的 strlen 函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从unicode开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符“！同时，也都是统一的”两个字节“，请注意”字符”和”字节”两个术语的不同，“字节”是一个8位的物理存贮单元，而“字符”则是一个文化相关的符号。在unicode中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。 ​ unicode同样也不完美，这里就有两个的问题，一个是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的。 ​ unicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。UTF-8就是在互联网上使用最广的一种unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节）。从unicode到utf-8并不是直接的对应，而是要过一些算法和规则来转换。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制）—————————————————————–0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 最后简单总结一下： 中国人民通过对 ASCII 编码的中文扩充改造，产生了 GB2312 编码，可以表示6000多个常用汉字。 汉字实在是太多了，包括繁体和各种字符，于是产生了 GBK 编码，它包括了 GB2312 中的编码，同时扩充了很多。 中国是个多民族国家，各个民族几乎都有自己独立的语言系统，为了表示那些字符，继续把 GBK 编码扩充为 GB18030 编码。 每个国家都像中国一样，把自己的语言编码，于是出现了各种各样的编码，如果你不安装相应的编码，就无法解释相应编码想表达的内容。 终于，有个叫 ISO 的组织看不下去了。他们一起创造了一种编码 UNICODE ，这种编码非常大，大到可以容纳世界上任何一个文字和标志。所以只要电脑上有 UNICODE 这种编码系统，无论是全球哪种文字，只需要保存文件的时候，保存成 UNICODE 编码就可以被其他电脑正常解释。 UNICODE 在网络传输中，出现了两个标准 UTF-8 和 UTF-16，分别每次传输 8个位和 16个位。于是就会有人产生疑问，UTF-8 既然能保存那么多文字、符号，为什么国内还有这么多使用 GBK 等编码的人？因为 UTF-8 等编码体积比较大，占电脑空间比较多，如果面向的使用人群绝大部分都是中国人，用 GBK 等编码也可以。","categories":[],"tags":[]},{"title":"A0006 SWD参考资料","slug":"A0006-SWD参考资料","date":"2018-07-04T06:28:59.000Z","updated":"2018-07-04T06:35:32.103Z","comments":true,"path":"2018/07/04/A0006-SWD参考资料/","link":"","permalink":"http://yoursite.com/2018/07/04/A0006-SWD参考资料/","excerpt":"","text":"转载https://blog.csdn.net/baiyibin0530/article/details/51682179 参考https://blog.csdn.net/u010066882/article/details/56030473 参考https://wenku.baidu.com/view/49a9277aeff9aef8951e061f.html 以下我的模拟SWD接口的板子简称为Host,目标MCU(即我要连接的板子)简称为Target。 SWD协议 ​ 故名思议，串行总线调试接口。我们需要3根线与目标MCU相连，SWDIO,SWDCLK和GND。 ​ -SWDIO 为双向Data口，主机到目标的数据传送。 ​ -SWDCLK 为时钟口，主机驱动。 ​ -GND GND脚。 ​ 首先参考《ARM Debug Interface V5》(注：该文档已有更新版本，并且对V5版本做了勘误)，对一些相关的协议相关说明有了较浅的认识。那接下来便找了个带SWD接口的板子，我这首先选了STM32F030，因为以后可以为生产线做离线编程器，当然随后也出现了一些问题，下文会说明。 ​ 连上相关物理连线，开始折腾。 ​ 看手册中有几个相对较重要的时序说明。 Trn-Trn：即Line turn-round，当总线上的数据传输方向发送改变时（比如由Host-&gt;Target变为Target-&gt;Host），需要插入Trn，Trn为一个CLK时序，关于对于Trn的理解自己也有些疑问。 Idle cycles：在一个总线完成后，可以立即进入下一个总线操作或者是勒令总线进入Idle 状态，此时可以插入Idle cycle。在这我用连续送出8个’0b0’来使得总线进入Idle状态。 Parity ：校验位，这个比较简单。分两个内容对命令头进行校验和对数据进行校验。命令头下文会说明。数据校验是对Data的0b0-0b31进行校验，如果‘1’的个数为奇数那校验位就为‘0b1’,如果‘0b1’的个数为偶数校验位就为‘0b0’。 ​ 理解了这几个，我们接下来看读写命令。 ​ 每个读写命令之前都会有个Host-&gt;Target的数据头。每个数据头为1Byte. -Start 起始位，始终为1，这也是Target判断总线从空闲状态退出的条件。 -APnDP 选择要访问的是DP寄存器还是AP寄存器。 - Rnw 选择是读还是写。 -A[2:3] DP或者AP寄存器的地址，注意它是低位在前。比如寄存器DP寄存器 Select 它的地址为0x08，那这儿的A为C(0b1000)，显然A[2:3]就为01。 -Praity 校验位，它是APnDP、RnW和A[2:3]共4个bit的校验位。 -Stop 停止位。始终为0。 -Park 该位确切来说应该始终为1，ADI V5中描述此位由总线上拉，但由于总线的上拉能力不足，会导致Target识别不了这个1。该勘误在ADI V5.2中有说明。 读命令为数据头+Trn+ACK+RDATA+Parity构成，但实际操作发现Trn这位是忽略掉的（所以不知道对此Trn的理解是否有误），及发送完数据头后立即读入ACK，判断Target是否正确响应。 写命令为数据头+Trn+ACK+Trn+WDATA+Parity，在这不同的是，在写命令时必须要考虑2个Trn的位置 看协议中首先在连接Target时需要进行LineReset，这个是最基础也是最最简单的命令。 具体实现为首先保证Host连续送出至少50个“1”，使得Target进行Line Reset,至少插入2个Idle,然后可以读取目标板的IDR，判断Target的类型 理解了整个，然后就进行操作验证，发现偶尔可以有数据ACK，继续查看手册，发现需要进行JTAG和SWD的切换操作。查看手册发现切换操作的时序如下。 可以简化为先进行一次LineReset,随后发送0X79，0XE7(高字节首先传送),接着再一次LineReset，随后便可以读IDR。但是发现了问题，用此方式可以读取到STM32F103的IDR，但STM32F030不行，在ARM网站查阅相关资料，发现了这个。 上图主要说在一个更早的协议中需要发送如下命令才能进行JTAG和SWD的切换。就是要发送0X6D,0XB7，尝试了下，这下能顺利读取到IDR了。疑惑的是STM32F0系列比F1出来要晚，居然用的老版本的协议？ 既然能够获取到IDR了，那接下来可以尝试着进行连接到AHB-AP了。用DP寄存器的SELECT来进行选择。这儿为了能够使得结果明显和确切，我选择了读取AP 0XFC 的IDR寄存器，来获取AP的特性，因为这个数据是只读的和确切的。 首先要用写入DP寄存器SELECT。 SELECT的具体描述可以参见ADI V5手册，在这有个说明，当时走了弯路。SELECT寄存器中有个APSEL选择位，这个是选择当前连接的AP，手册中没有详细说明它的定义。后来在另外的文档中发现该值为0x00，AHB-AP。APBANKSEL为选择需要访问的BANK地址，比如IDR寄存器的地址为0XFC，那它的BANKSEL为F，如果为TAR寄存器，那它的BANKSEL为0。 连接到AHB-AP后就能进行你想要的操作了。比如我可以读取MCU的独立ID，就可以通过MEM-AP来操作。也可以对MCU进行擦除或者编程。 在做编程之前，首先将MCU进入Halt状态，然后访问MCU相关FLASH控制寄存器进行读写即可。 在STM32F030编程时需要注意的是STM32F030的FLASH的传输方式，我未采用Packet的传输方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192LineReset代码static void SwdLineReset(void)&#123; u8 i; SWD_OUT; SWD_DIO_H; for(i=0;i&lt;56;i++)&#123; SWD_Delay(); SWD_CLK_H; SWD_Delay(); SWD_CLK_L;&#125;&#125;写命令头函数static void SwdSendByte(u8 dat)&#123; u8 i; SWD_OUT; for(i=0;i&lt;8;i++) &#123; if((dat&amp;0x80)==0x80) &#123; SWD_DIO_H; &#125; else &#123; SWD_DIO_L; &#125; dat&lt;&lt;=1; SWD_CLK_H; SWD_Delay(); SWD_CLK_L; SWD_Delay(); &#125;&#125;读取一个data函数static u32 SeqRead(u8 cmd)&#123; u32 dat=0; u8 i=0; SwdSendByte(cmd); SWD_IN; for(i=0;i&lt;3;i++)//ack 此处需要处理判断 &#123; SWD_CLK_H; SWD_Delay(); SWD_CLK_L; SWD_Delay(); &#125;dat=0; for(i=0;i&lt;32;i++) &#123; dat=dat&gt;&gt;1; SWD_CLK_H; SWD_Delay(); SWD_CLK_L; if(SWD_DII) &#123; dat|=0x80000000; &#125; SWD_Delay(); &#125; //parity SWD_IN; //trn for(i=0;i&lt;2;i++) &#123; SWD_CLK_H; SWD_Delay(); SWD_CLK_L; SWD_Delay(); &#125; SWD_DIO_L; SWD_OUT; for(i=0;i&lt;5;i++) &#123; SWD_CLK_H; SWD_Delay(); SWD_CLK_L; SWD_Delay(); SWD_CLK_H; SWD_Delay(); SWD_CLK_L; SWD_Delay(); &#125; SWD_IN; //trn return dat;&#125;","categories":[],"tags":[]},{"title":"A0005 树莓派教程","slug":"A0005-树莓派教程","date":"2018-07-04T06:28:53.000Z","updated":"2018-07-04T06:34:47.142Z","comments":true,"path":"2018/07/04/A0005-树莓派教程/","link":"","permalink":"http://yoursite.com/2018/07/04/A0005-树莓派教程/","excerpt":"","text":"树莓派3B+搭建https://blog.csdn.net/yalecaltech/article/details/79426959 初次使用树莓派并启用root管理员（登录root管理员）https://blog.csdn.net/faryang/article/details/50779767 树莓派Raspbian系统密码是多少？树莓派Raspbian系统默认登录用户名为pi，该账户默认密码是raspberry（可在raspi-config中修改）。树莓派的Raspbian系统root用户默认是禁用状态，且没有密码，所以要先设置个密码，然后开启才能正常使用。 使用pi账户进行登陆命令行，执行命令：【sudo passwd root】设置root用户密码，然后在执行【sudo passwd –unlock root】开启root账户，在使用【su root】测试是否生效！ 重新锁定root账户可执行命令：sudo passwd –lock root Advanced IP Scanner 可以在树莓派没显示的情况下扫描到ip地址 树莓派初次使用（史上最全最详细教程！！）https://blog.csdn.net/xyscript/article/details/65487038 学习笔记：使用opencv做双目测距（相机标定+立体匹配+测距）.https://www.cnblogs.com/daihengchen/p/5492729.html 如何安装树莓派摄像头模块https://linux.cn/article-3650-1.html 用树莓派实现实时的人脸检测http://www.52pi.net/archives/1435 Raspbian Stretch: Install OpenCV 3 + Python on your Raspberry Pihttps://www.pyimagesearch.com/2017/09/04/raspbian-stretch-install-opencv-3-python-on-your-raspberry-pi/ opencv下载资源https://blog.csdn.net/yanzi1225627/article/details/47668021 （树莓派、linux通用）OpenCV3源码方式安装教程（最新3.4.1）照着做成功的显示了图片https://blog.csdn.net/leaves_joe/article/details/67656340","categories":[],"tags":[]},{"title":"A0004 Hexo教程","slug":"A0004-Hexo教程","date":"2018-07-04T06:28:12.000Z","updated":"2018-07-04T06:34:28.175Z","comments":true,"path":"2018/07/04/A0004-Hexo教程/","link":"","permalink":"http://yoursite.com/2018/07/04/A0004-Hexo教程/","excerpt":"","text":"https://www.cnblogs.com/visugar/p/6821777.html https://blog.csdn.net/qq_26927285/article/details/78761814 https://blog.csdn.net/lyb3b3b/article/details/78706077 http://blog.sina.com.cn/s/blog_4c44643f0102vuju.html 跟换主题https://github.com/ppoffice/hexo-theme-hueman/wiki/Installation http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html hexo 如何上传图片 http://www.isetsuna.com/hexo/writing-image/ https://blog.csdn.net/qq_26891045/article/details/51693571 markdown语法https://www.jianshu.com/p/1e402922ee32/","categories":[],"tags":[]},{"title":"A0003 Opencv教程","slug":"A0003-Opencv教程","date":"2018-07-04T06:27:58.000Z","updated":"2018-07-04T06:33:42.884Z","comments":true,"path":"2018/07/04/A0003-Opencv教程/","link":"","permalink":"http://yoursite.com/2018/07/04/A0003-Opencv教程/","excerpt":"","text":"OpenCV学习笔记（一）——安装配置、第一个程序 OpenCV学习笔记（二）——新版本模块结构 OpenCV学习笔记（三）——Mat，图像的新容器 OpenCV学习笔记（四）——新版本的数据结构core OpenCV学习笔记（五）——2.0以上版本和以下版本的数据兼容 OpenCV学习笔记（六）——对XML和YAML文件实现I/O操作 OpenCV学习笔记（七）——图像处理之滤波器ImgProc OpenCV学习笔记（八）——图像处理之直方图ImgProc OpenCV学习笔记（九）——2维特征Feature2D OpenCV学习笔记（十）——图形交互和媒体接口HighGUI OpenCV学习笔记（十一）——谈谈像素的类型和对Templates的限制使用 OpenCV学习笔记（十二）——随机数产生器RNG OpenCV学习笔记（十三）——模板匹配 OpenCV学习笔记（十四）——图像结构分析与形状描述ImgProc OpenCV学习笔记（十六）——CamShift研究 OpenCV学习笔记（十五）——摄像机的标定和3D重建calib3D OpenCV学习笔记（十九）——浅尝contrib OpenCV学习笔记（二十）——手势识别 OpenCV学习笔记（十七）——运动分析和物体跟踪Video OpenCV学习笔记（十八）——图像的各种变换（cvtColor*+）imgproc OpenCV学习笔记（二十一）——绘图函数core OpenCV学习笔记（二十二）——粒子滤波跟踪方法 OpenCV学习笔记（二十三）——OpenCV的GUI之凤凰涅槃Qt OpenCV学习笔记（二十四）——初探机器学习库ml OpenCV学习笔记（二十五）——OpenCV图形界面设计Qt+VS2008 OpenCV学习笔记（二十六）——小试SVM算法ml OpenCV学习笔记（二十七）——基于级联分类器的目标检测objdect OpenCV学习笔记（二十八）——光流法对运动目标跟踪Video OpenCV学习笔记（二十九）——视频前景的提取Video OpenCV学习笔记（三十）——解开VideoInput面纱highgui OpenCV学习笔记（三十一）——让demo在他人电脑跑起来 OpenCV学习笔记（三十二）——制作静态库的demo，没有dll也能hold住 OpenCV学习笔记（三十三）——用haar特征训练自己的分类器（再做手势检测）OpenCV学习笔记（三十四）——OpenCV路在何方 OpenCV学习笔记（三十五）——用Qt做摄像头读取 OpenCV学习笔记（三十六）——Kalman滤波做运动目标跟踪 OpenCV学习笔记（三十七）——实用函数、系统函数、宏core OpenCV学习笔记（三十八）——显示当前FPS OpenCV学习笔记（三十九）——再谈OpenCV的数据结构，Mat是如此强大 OpenCV学习笔记（四十）——再谈OpenCV数据结构Mat详解 OpenCV学习笔记（四十一）——再看基础数据结构core OpenCV学习笔记（四十二）——Mat数据操作之普通青年、文艺青年、暴力青年 OpenCV学习笔记（四十三）——存取像素值操作汇总core OpenCV学习笔记（四十四）——初探GPU OpenCV学习笔记（四十五）——小试随机森林（random forest）算法ml OpenCV学习笔记（四十六）——FAST特征点检测features2D OpenCV学习笔记（四十七）——VideoWriter生成视频流highgui OpenCV学习笔记（四十八）——PCA算法实现core OpenCV学习笔记（四十九）——号外！OpenCV-2.4.0 release 千呼万唤始出来 OpenCV学习笔记（五十）——Algorithm类介绍（core） OpenCV学习笔记（五十一）——imge stitching图像拼接stitching OpenCV学习笔记（五十二）——号外：OpenCV 2.4.1 又出来了。。。。。 OpenCV学习笔记（五十三）——新版本2.4.2简介&amp;FREAK和ORB特征描述子效果对比features2d OpenCV学习笔记（五十四）——概述FaceRecognizer人脸识别类contrib OpenCV学习笔记（五十五）——用OpenCV做人脸识别和性别识别contrib","categories":[],"tags":[]},{"title":"A0002 Opencv教程","slug":"A0002-Opencv教程","date":"2018-07-04T06:27:46.000Z","updated":"2018-07-04T06:33:19.037Z","comments":true,"path":"2018/07/04/A0002-Opencv教程/","link":"","permalink":"http://yoursite.com/2018/07/04/A0002-Opencv教程/","excerpt":"","text":"Python环境搭建之OpenCV https://www.cnblogs.com/lclblack/p/6377710.html Python环境搭建之OpenGL http://www.cnblogs.com/lclblack/p/6378212.html 报错缺少VS14………/lib——–&gt;Microsoft Visual C++ 14.0 is required. 的解决办法 https://blog.csdn.net/woay2008/article/details/79905627 https://blog.csdn.net/TH_NUM/article/details/77095177 解决后 运行后报错 OpenGL.error.NullFunctionError: Attempt to call an undefined function glutInit, check for bool(glutInit) before calling 原因 如果是32位系统,可以直接使用pip命令:pip install pyopengl 应为这个命令默认安装32位的(别人说的,自己试过) 如果提示:’pip’不是内部或外部命令,也不是可运行的程序或批处理文件将python安装目录下的scripts目录(例如D:/Python27/Scripts)添加到系统环境变量path里,注意前加分号。再执行该命令也可以到网址下载安装版本,不过选择适合自己系统的版本 https://pypi.python.org/pypi/PyOpenGL (2)如果是64位的系统,可以到这个网址下载符合已安装Python的版本,比如: PyOpenGL_accelerate‑3.1.1‑cp36‑cp36m‑win_amd64.whl cp36指的是python3.6以上的版本 amd64指的是64位系统(大概是这个样子)然后执行pip命令: pip install PyOpenGL_accelerate‑3.1.1‑cp36‑cp36m‑win_amd64.whl","categories":[],"tags":[]},{"title":"A0001 Opencv教程","slug":"A0001-Opencv教程","date":"2018-07-04T06:27:35.000Z","updated":"2018-07-04T06:32:49.730Z","comments":true,"path":"2018/07/04/A0001-Opencv教程/","link":"","permalink":"http://yoursite.com/2018/07/04/A0001-Opencv教程/","excerpt":"","text":"系列文章 – OpenCV入门教程 https://www.cnblogs.com/mq0036/p/5902104.html","categories":[],"tags":[]},{"title":"C0001 C计算器001","slug":"C0001-C计算器001","date":"2018-07-04T06:26:15.000Z","updated":"2018-07-04T06:36:29.762Z","comments":true,"path":"2018/07/04/C0001-C计算器001/","link":"","permalink":"http://yoursite.com/2018/07/04/C0001-C计算器001/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt; int main(void)&#123; int frist = 0; int second = 0; int stop = 0; char m[100]; gets(m); printf(\"%s\\n\",m); int item = 0; for(int index = 0; index &lt; sizeof(m);index++ ) &#123; if(m[index] == '+') item = index; if(m[index] == '-') item = index; if(m[index] == '*') item = index; if(m[index] == '/') item = index; if(m[index] == '\\0') &#123; stop = index; break; &#125; &#125; if(item &gt; 0) printf(\"位置%d是加号\\n\",item); else printf(\"没有加号\\n\"); for(int index = 0; index &lt; item;index++ ) frist = (m[index]-48) + frist*10; for(int index = item + 1; index &lt; stop;index++ ) second = (m[index]-48) + second*10; printf(\"frist = %d\\n\",frist); printf(\"second = %d\\n\",second); switch(m[item]) &#123; case '+': printf(\"%d\",frist + second) ; break; case '-': printf(\"%d\",frist - second) ; break; case '*': printf(\"%d\",frist * second) ; break; case '/': printf(\"%lf\",frist / second) ; break; default : break; &#125; return 0; &#125;","categories":[],"tags":[]}]}